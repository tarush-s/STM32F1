#include "stm32f10x.h"
volatile static myTicks=0;
uint8_t rec_data;

//prototype start
void spi(void);
void ports(void);
void SysTick_Handler(void);
void delayMs(uint16_t ms);
uint8_t recieve(void);
void CS_Disable (void);
void CS_Enable (void);
void blink (void);
// prototype end

int main()
{

	spi();
	ports();
	


	while(1)
	{

		rec_data=recieve();
		
		if(rec_data==0b00000001) // IDR -> INPUT DATA REGISTER | CHECKING STATUS OF A0
		{
			blink();
		}

   
	}


}



void ports(void)
{
	RCC->APB2ENR |=  (1<<2);  // Enable GPIOA clock
	GPIOA->CRL = 0;
	GPIOA->CRL |= (11U<<20);   // PA5 (SCK) AF output Push Pull
	GPIOA->CRL |= GPIO_CRL_CNF7_1;  // PA7 (MOSI) AF INPUT
	GPIOA->CRL |= GPIO_CRL_MODE6 | GPIO_CRL_CNF6_1;    // PA6 (MISO) OUTPUT
	GPIOA->CRL |= (3<<16);    // PA4 used for CS, GPIO Output 
	
	RCC -> APB2ENR |= 0x10; // ENABLE PORT C
	GPIOC -> CRH &= 0xFF0FFFFF; // RESET PIN 13
	GPIOC -> CRH |= 0x00300000; // PIN 13 | OUTPUT MODE | MAX SPEED = 50Hz

}
void spi()
{
	RCC->APB2ENR |= (1<<12);  // Enable SPI1 CLock
	

  SP1->CR1 |=(1<<6);	
  SPI1->CR1 |= (1<<0)|(1<<1);   // CPOL=1, CPHA=1
	
  SPI1->CR1 &= ~(1<<2);  // slave mode Mode
	
  SPI1->CR1 |= (3<<3);  // BR[2:0] = 011: fPCLK/16, PCLK2 = 80MHz, SPI clk = 5MHz
	
  SPI1->CR1 &= ~(1<<7);  // LSBFIRST = 0, MSB first
	
  SPI1->CR1 &=~(1<<9);  // SSM=1, SSi=1 -> Software Slave Management
	
  SPI1->CR1 &= ~(1<<10);  // RXONLY = 0, full-duplex
	
  SPI1->CR1 &= ~(1<<11);  // DFF=0, 8 bit data
	
  SPI1->CR2 |= (1<<2);
}

uint8_t recieve(void)
{

    // Wait until receive complete
    while (!(SPI1->SR & ((u16)(0x0001))));
	    // Return received data from SPI data register
    return SPI1->DR;
}
void blink ()
{
	int t=0;
	while (t<2)
	{
		GPIOC -> ODR |= 0x2000;
		delayMs(100);
		GPIOC ->  ODR &= ~0x2000;
		delayMs(100);
		t++;
	}
}
void SysTick_Handler(void)
{
	myTicks++;
}

void delayMs(uint16_t ms)
{
	myTicks = 0;
	while(myTicks<ms);
}
void CS_Enable (void)
{
	GPIOA->BSRR |= (1<<9)<<16;
}

void CS_Disable (void)
{
	GPIOA->BSRR |= (1<<9);
}

