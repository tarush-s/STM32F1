#include "stm32f10x.h"
volatile static myTicks=0;

//prototype start
void spi(void);
void ports(void);
void SysTick_Handler(void);
void delayMs(uint16_t ms);
void send(char tx_char);
void CS_Disable (void);
void CS_Enable (void);
// prototype end

int main()
{

	spi();
	ports();
	


	while(1)
	{

		if(GPIOA -> IDR & 0x00000001) // IDR -> INPUT DATA REGISTER | CHECKING STATUS OF A0
		{
			CS_Enable();
			send('A');
			CS_Disable();
			delayMs(100);
		}

   
	}


}



void ports(void)
{
	RCC->APB2ENR |=  RCC_APB2ENR_IOPAEN;  // Enable GPIOA clock
	
	//spi ports
	GPIOA->CRL |=(1<<21);
	GPIOA->CRL &=~(1U<<20);
	GPIOA->CRL |=(1<<22) | (1<<23);
	
	GPIOA->CRL |=(1<<29);
	GPIOA->CRL &=~(1U<<28);
	GPIOA->CRL |=(1<<30) | (1U<<31);
	
	
	
	
	
	GPIOA -> CRL &= 0xFFFFFFF0; // RESET PORT A TO 0
	GPIOA -> CRL |= 0x8; // INPUT MODE | PUSH-PULL| PIN A0

}
void spi()
{
	RCC->APB2ENR |= (1<<12);  // Enable SPI1 CLock
//*******Setup SPI peripherals*****
SPI1->CR1 |= 0x4; // Master Mode
SPI1->CR1 |= 0x31; // fclk / 265
SPI1->CR2 |= 0x4;
SPI1->CR1 |= 0x40; // Enabling SPI SPI periph

 }

void send(char tx_char)
{
        {
		SPI1->DR = tx_char;
		while(SPI1->SR & 0x80){}

	}
  
}
void SysTick_Handler(void)
{
	myTicks++;
}

void delayMs(uint16_t ms)
{
	myTicks = 0;
	while(myTicks<ms);
}
void CS_Enable (void)
{
	GPIOA->BSRR |= (1<<4)<<16;
}

void CS_Disable (void)
{
	GPIOA->BSRR |= (1<<4);
}
